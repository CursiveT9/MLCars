import joblib
import numpy as np

# Загрузка сохранённой модели
# Используем joblib для загрузки модели и связанных данных из файла
model_data = joblib.load('logistic_model.pkl')

# Извлечение нужных данных из модели
# Веса модели, маппинги категориальных данных, средние значения и стандартные отклонения
weights = model_data['model']
category_mappings = model_data['category_mappings']
mean_values = model_data['mean_values']
std_values = model_data['std_values']

# Сигмоидная функция (функция активации)
def sigmoid(z):
    return 1 / (1 + np.exp(-z))

# Предсказание вероятности
def predict(X, weights):
    return sigmoid(np.dot(X, weights))

# 7000
# 65000
# 70000
# 70000
# 95000
# 95000
# 333000
# 340000
# 540000
# 540000
# 1520000
# 1520000
# 1530000
# 1530000
# 1600000
# 1630000
# 1640000
# 1650000
# 2499000
# 3200000

# Данные для проверки
# Список автомобилей с их характеристиками
data_to_check = [
    ['Opel', 'Седан', '', 'Бензин', 1986.0, 444000.0, 'Механика', 112.0, 1.8, 'Кировское'],
    ['Лада', 'Седан', '', 'Бензин', 1985.0, 123000.0, 'Механика', 72.0, 1.5, 'Шерловая Гора'],
    ['ГАЗ', 'Седан', '', 'Бензин', 1997.0, 170000.0, 'Механика', 100.0, 2.4, 'Борзя'],
    ['Лада', 'Седан', '', 'Бензин', 1970.0, 73000.0, 'Механика', 64.0, 1.3, 'Чита'],
    ['Лада', 'Седан', '', 'Бензин', 1995.0, 33000.0, 'Механика', 79.0, 1.7, 'Краснокаменск'],
    ['Nissan', 'Универсал', '', 'Бензин', 1998.0, 200000.0, 'АКПП', 125.0, 1.8, 'Чита'],
    ['Toyota', 'Седан', '', 'Бензин', 2009.0, 100000.0, 'АКПП', 203.0, 2.5, 'Чита'],
    ['Toyota', 'Седан', '', 'Бензин', 2004.0, 205000.0, 'АКПП', 132.0, 1.8, 'Чита'],
    ['Daihatsu', 'Хэтчбек 5 дв.', '', 'Бензин', 2018.0, 70000.0, 'Вариатор', 49.0, 0.7, 'Чита'],
    ['Mitsubishi', 'Джип 5 дв.', '', 'Бензин', 1993.0, 300000.0, 'АКПП', 155.0, 3.0, 'Чита'],
    ['Toyota', 'Седан', '', 'Бензин', 2016.0, 14000.0, 'Вариатор', 109.0, 1.5, 'Чита'],
    ['Toyota', 'Седан', '', 'Бензин', 2019.0, 19000.0, 'Вариатор', 109.0, 1.5, 'Чита'],
    ['Toyota', 'Седан', '', 'Бензин', 2016.0, 14000.0, 'Вариатор', 109.0, 1.5, 'Чита'],
    ['Mitsubishi', 'Джип 5 дв.', '', 'Дизель', 2006.0, 370000.0, 'АКПП', 165.0, 3.2, 'Севастополь'],
    ['Toyota', 'Джип 5 дв.', '', 'Бензин', 2019.0, 28000.0, 'Вариатор', 98.0, 1.0, 'Чита'],
    ['Toyota', 'Джип 5 дв.', '', 'Бензин', 2019.0, 28000.0, 'Вариатор', 98.0, 1.0, 'Чита'],
    ['Toyota', 'Джип 5 дв.', '', 'Бензин', 2019.0, 28000.0, 'Вариатор', 98.0, 1.0, 'Чита'],
    ['Toyota', 'Минивэн', '', 'Бензин', 2014.0, 94000.0, 'Вариатор', 99.0, 1.8, 'Чита'],
    ['Toyota', 'Седан', '', 'Бензин', 2018.0, 97000.0, 'Вариатор', 184.0, 2.5, 'Чита'],
    ['Mercedes-Benz', 'Седан', '', 'Бензин', 2013.0, 187000.0, 'АКПП', 455.0, 4.7, 'Севастополь']
]

# Индексы категориальных столбцов в данных
# Указываем индексы столбцов, которые содержат категориальные данные
categorical_columns_indices = [0, 1, 2, 3, 6, 9]

# Обработка каждой строки данных
# Проходим по каждому автомобилю в списке данных для проверки
for i, new_data in enumerate(data_to_check):
    # Преобразование категориальных данных с использованием маппинга
    new_data_transformed = []
    for j, col in enumerate(new_data):
        if j in categorical_columns_indices:  # Если это категориальный столбец
            # Получаем название столбца по индексу
            column_name = list(category_mappings.keys())[categorical_columns_indices.index(j)]
            if col in category_mappings[column_name]:
                # Если значение найдено в маппинге, заменяем на индекс
                new_data_transformed.append(np.where(category_mappings[column_name] == col)[0][0])
            else:
                # Если значение не найдено в маппинге, используем дефолтное значение (-1)
                new_data_transformed.append(-1)
        else:
            # Если это числовой столбец, просто добавляем значение
            new_data_transformed.append(col)

    # Преобразование в числовой тип
    new_data_transformed = np.array(new_data_transformed, dtype=float)

    # Нормализация данных
    # Используем сохраненные средние значения и стандартные отклонения
    new_data_transformed = (new_data_transformed - mean_values) / std_values
    new_data_transformed = np.array(new_data_transformed).reshape(1, -1)

    # Добавляем столбец из единиц
    new_data_transformed = np.hstack((np.ones((new_data_transformed.shape[0], 1)), new_data_transformed))

    # Предсказание вероятности
    # Используем функцию predict для получения вероятности
    probability = predict(new_data_transformed, weights)

    # Преобразование вероятности в класс (1 — дороже миллиона, 0 — нет)
    predicted_class = (probability >= 0.5).astype(int)

    # Вывод результата
    print(f"Автомобиль {i + 1}:")
    print(f"  Данные: {new_data}")
    print(f"  Вероятность, что машина дороже миллиона: {probability[0]:.2f}")
    print(f"  Класс: {'Дороже миллиона' if predicted_class[0] == 1 else 'Не дороже миллиона'}")
    print()